<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Realistic avatars — Networked-Aframe</title>
    <meta name="description" content="Realistic avatars — Networked-Aframe" />

    <script src="https://aframe.io/releases/1.7.0/aframe.min.js"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.8.1/socket.io.min.js"></script>
    <script src="/easyrtc/easyrtc.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/networked-aframe@0.14.0/dist/networked-aframe.min.js"></script>

    <script src="https://cdn.jsdelivr.net/gh/c-frame/aframe-extras@7.5.4/dist/aframe-extras.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/aframe-environment-component@1.5.0/dist/aframe-environment-component.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@fern-solutions/aframe-mirror@1.1.1/dist/mirror.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/c-frame/aframe-cursor-teleport@1.6.0/dist/aframe-cursor-teleport-component.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/aframe-blink-controls@0.4.3/dist/aframe-blink-controls.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/AdaRoseCannon/aframe-xr-boilerplate@bca4792/simple-navmesh-constraint.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/c-frame/aframe-gltf-model-plus@1.0.0/dist/gltf-model-plus.min.js"></script>
    <script>
      window.uiSettings = {
        showRandomAvatarButton: true,
        showDieButton: true,
      };
    </script>
    <script src="/dist/components.js"></script>
    <script defer src="/dist/ui.js"></script>
  </head>

  <body>
    <a-scene
      light="defaultLightsEnabled:false"
      renderer="stencil:true"
      networked-scene="
        connectOnLoad: false;
        room: forest;
        debug: true;
        adapter: wseasyrtc;
        audio: false;
        video: false;
    "
      shadow="type: pcfsoft"
      gltf-model="meshoptDecoderPath:https://unpkg.com/meshoptimizer@0.19.0/meshopt_decoder.js"
      raycaster="far: 100; objects: .clickable,[link];"
      cursor="rayOrigin: mouse"
    >
      <a-assets>
        <template id="avatar-template">
          <a-entity player-info>
            <a-entity class="model">
              <a-text class="nametag" align="center" value="?" position="0 2.1 0" scale=".5 .5 .5"></a-text>
            </a-entity>
            <a-entity class="camera" position="0 1.6 0"></a-entity>
          </a-entity>
        </template>
        <img id="thumbJapan" crossorigin="anonymous" src="https://cdn.aframe.io/link-traversal/thumbs/japan.png" />
        <img id="thumbForest" crossorigin="anonymous" src="https://cdn.aframe.io/link-traversal/thumbs/forest.png" />
      </a-assets>

      <a-entity id="scene">
        <a-entity environment="preset:forest;shadow:true"></a-entity>
        <a-plane class="ground" position="0 0 0" rotation="-90 0 0" width="100" height="100" visible="false"></a-plane>
        <a-entity light="type:ambient;intensity:0.5"></a-entity>
        
        <a-mirror id="mirror" class="collidable" position="0 1.8 -3" scale="5 3 1" layers="0,3">
          <a-box color="black" position="0 0 -0.02" scale="1.02 1.02 0.01"></a-box>
        </a-mirror>
        
        <a-link href="japan.html" position="-2 1.5 3" image="#thumbJapan"></a-link>
        
        <a-cylinder class="collidable" radius="0.25" height="0.4" position="1.5 0.2 -2" rotation="0 180 0"></a-cylinder>
        <a-cylinder class="collidable" radius="0.25" height="0.4" position="0.3 0.2 -2" rotation="0 180 0"></a-cylinder>
        
        <!-- Invisible body for the car -->
        <a-box id="ferrari-body" class="collidable" pushable position="0 0.6 -7" width="1.8" height="0.1" depth="4" visible="false"></a-box>
        <!-- Visual model for the car -->
        <a-entity id="ferrari" gltf-model="url(assets/ferrari.glb)" follow="target: #ferrari-body;" scale="1 1 1"></a-entity>

      </a-entity>

      <a-entity id="rig" collider movement-controls="fly:false;" spawn-in-circle="radius:1" networked="template:#avatar-template;attachTemplateToLocal:false" player-info>
        <a-entity id="player" class="camera" camera position="0 1.6 0" look-controls></a-entity>
        <a-entity id="left-hand" networked-hand-controls="hand: left" laser-controls="hand: left"></a-entity>
        <a-entity id="right-hand" networked-hand-controls="hand:right" laser-controls="hand: right"></a-entity>
      </a-entity>
    </a-scene>

    <script>
      // Component to make one entity follow another
      AFRAME.registerComponent('follow', {
        schema: { target: { type: 'selector' } },
        tick: function () {
          if (!this.data.target) return;
          this.el.object3D.position.copy(this.data.target.object3D.position);
          this.el.object3D.quaternion.copy(this.data.target.object3D.quaternion);
        }
      });

      // Player collider: stops the player from penetrating any .collidable object
      AFRAME.registerComponent('collider', {
        schema: { distance: { default: 0.7 } },
        init: function () {
          this.raycaster = new THREE.Raycaster();
          this.lastSafePosition = new THREE.Vector3();
          this.directions = [new THREE.Vector3(0, 0, -1), new THREE.Vector3(0, 0, 1), new THREE.Vector3(-1, 0, 0), new THREE.Vector3(1, 0, 0)];
          this.el.addEventListener('loaded', () => this.el.object3D.getWorldPosition(this.lastSafePosition));
        },
        tick: function (time, delta) {
          const collidableEls = this.el.sceneEl.querySelectorAll('.collidable');
          if (collidableEls.length === 0) return;
          const collidables = [];
          collidableEls.forEach(el => collidables.push(el.object3D));

          let collision = false;
          for (const dir of this.directions) {
            const worldDir = dir.clone().applyQuaternion(this.el.object3D.quaternion);
            this.raycaster.set(this.el.object3D.position, worldDir);
            this.raycaster.far = this.data.distance;
            const intersects = this.raycaster.intersectObjects(collidables, true);

            if (intersects.length > 0 && intersects[0].distance < this.data.distance) {
              const hitEl = intersects[0].object.el;
              if (hitEl && hitEl.components.pushable) {
                const pushStrength = 0.002;
                const pushVector = worldDir.clone().multiplyScalar(pushStrength * delta);
                hitEl.components.pushable.push(pushVector);
              }
              this.el.object3D.position.copy(this.lastSafePosition);
              collision = true;
              break;
            }
          }
          if (!collision) {
            this.el.object3D.getWorldPosition(this.lastSafePosition);
          }
        }
      });

      // Pushable component: handles its own gravity and can be pushed
      AFRAME.registerComponent('pushable', {
        init: function () {
          this.raycaster = new THREE.Raycaster();
          this.downVector = new THREE.Vector3(0, -1, 0);
        },
        push: function(vector) {
          this.el.object3D.position.add(vector);
        },
        tick: function() {
          const groundEls = this.el.sceneEl.querySelectorAll('.ground, .environmentGround');
          if (groundEls.length === 0) return;
          const grounds = [];
          groundEls.forEach(el => grounds.push(el.object3D));

          this.raycaster.set(this.el.object3D.position, this.downVector);
          const intersects = this.raycaster.intersectObjects(grounds, true);
          if (intersects.length > 0) {
            const height = this.el.getAttribute('geometry').height;
            this.el.object3D.position.y = intersects[0].point.y + height / 2;
          }
        }
      });
    </script>
  </body>
</html>
