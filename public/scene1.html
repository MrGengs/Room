<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>AR-Room</title>
    <meta name="description" content="AR          <!-- Arrow indicator for sepeda -->
          <a-entity id="sepeda-arrow" 
            gltf-model="url(assets/arrow.glb)"
            position="0 2.5 0" 
            rotation="0 0 0"
            scale="0.5 0.5 0.5"
            visible="false">
          </a-entity>>

    <script src="https://aframe.io/releases/1.7.0/aframe.min.js"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.8.1/socket.io.min.js"></script>
    <script src="/easyrtc/easyrtc.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/networked-aframe@0.14.0/dist/networked-aframe.min.js"></script>

    <script src="https://cdn.jsdelivr.net/gh/c-frame/aframe-extras@7.5.4/dist/aframe-extras.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/aframe-environment-component@1.5.0/dist/aframe-environment-component.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@fern-solutions/aframe-mirror@1.1.1/dist/mirror.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/c-frame/aframe-cursor-teleport@1.6.0/dist/aframe-cursor-teleport-component.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/aframe-blink-controls@0.4.3/dist/aframe-blink-controls.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/AdaRoseCannon/aframe-xr-boilerplate@bca4792/simple-navmesh-constraint.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/c-frame/aframe-gltf-model-plus@1.0.0/dist/gltf-model-plus.min.js"></script>
    <script src="/dist/components.js"></script>
  </head>

  <body>
    <a-scene
      light="defaultLightsEnabled:false"
      renderer="stencil:true"
      networked-scene="
        connectOnLoad: false;
        room: forest;
        debug: true;
        adapter: wseasyrtc;
        audio: false;
        video: false;
    "
      shadow="type: pcfsoft"
      gltf-model="meshoptDecoderPath:https://unpkg.com/meshoptimizer@0.19.0/meshopt_decoder.js"
      raycaster="far: 100; objects: .clickable,[link];"
      cursor="rayOrigin: mouse"
    >
      <a-assets>
        <template id="avatar-template">
          <a-entity player-info>
            <a-entity class="model">
              <a-text class="nametag" align="center" value="?" position="0 2.1 0" scale=".5 .5 .5"></a-text>
            </a-entity>
            <a-entity class="camera" position="0 1.6 0"></a-entity>
          </a-entity>
        </template>
        <img id="thumbJapan" crossorigin="anonymous" src="https://cdn.aframe.io/link-traversal/thumbs/japan.png" />
        <img id="thumbForest" crossorigin="anonymous" src="https://cdn.aframe.io/link-traversal/thumbs/forest.png" />
      </a-assets>

      <a-entity id="scene">
        <!-- School building with collision -->
        <a-entity id="school-group" position="0 -11 0">
          <a-gltf-model src="assets/sekolah.glb" scale="2 2 2" rotation="0 0 0"></a-gltf-model>
          <!-- Multiple collision boxes for better coverage -->
          <a-box
            class="collidable"
            position="0 5 0"
            width="20"
            height="22"
            depth="20"
            visible="false"
            static-body="mass: 0"
          ></a-box>
          <a-box
            class="collidable"
            position="0 5 0"
            width="20"
            height="22"
            depth="20"
            visible="false"
            collision-filter="collideForces: false;"
          ></a-box>
        </a-entity>
        <a-plane class="ground" position="0 0 0" rotation="-90 0 0" width="100" height="100" visible="true"></a-plane>
        <a-entity light="type:ambient;intensity:0.5"></a-entity>

        <a-mirror id="mirror" class="collidable" position="0 1.8 -3" scale="5 3 1" layers="0,3">
          <a-box color="black" position="0 0 -0.02" scale="1.02 1.02 0.01"></a-box>
        </a-mirror>

        <!-- Car collision system -->
        <a-entity id="car-group" position="0 0 2" rotation="0 180 0">
          <!-- Main collision body for the car -->
          <a-box
            id="ferrari-body"
            class="collidable"
            pushable
            physics-object="mass: 1200"
            position="0 0.6 0"
            width="1.8"
            height="1.2"
            depth="4.0"
            visible="false"
          ></a-box>
          <!-- Visual model for the car -->
          <a-entity id="ferrari" gltf-model="url(assets/ferrari.glb)" position="0 0 0" scale="1 1 1"></a-entity>
          <!-- Arrow indicator for car -->
          <a-entity id="car-arrow" 
            gltf-model="url(assets/arrow.glb)"
            position="0 2.5 0" 
            rotation="0 0 0"
            scale="0.5 0.5 0.5"
            visible="false">
          </a-entity>
        </a-entity>

        <!-- Sepeda model with collision -->
        <a-entity id="sepeda-group" position="3 0.6 3" rotation="0 180 0">
          <!-- Main collision body for the bicycle -->
          <a-box
            id="sepeda-body"
            class="collidable"
            pushable
            physics-object="mass: 50"
            position="0 0.3 0"
            width="1.0"
            height="0.6"
            depth="2.0"
            visible="false"
          ></a-box>
          <!-- Visual model for the bicycle -->
          <a-entity id="sepeda" gltf-model="url(assets/sepeda.glb)" scale="0.5 0.5 0.5"></a-entity>
          <!-- Arrow indicator for sepeda -->
          <a-entity id="sepeda-arrow" 
            gltf-model="url(assets/Orange Arrow.glb)"
            position="0 1.5 0" 
            rotation="0 180 0"
            scale="0.3 0.3 0.3"
            visible="false">
          </a-entity>
        </a-entity>
        
        <!-- Portal back to index.html -->
        <a-link
          change-room="on:obbcollisionstarted;room:lobby;url:index.html"
          link="on:click"
          href="index.html"
          title="Kembali ke Lobby"
          image="#thumbForest"
          position="-8 1.6 -2"
          rotation="0 90 0"
          class="clickable"
          event-set__mouseenter="material.opacity: 0.8"
          event-set__mouseleave="material.opacity: 0.6"
        >
          <a-box position="0 0 0.5" obb-collider visible="false"></a-box>
        </a-link>
      </a-entity>

      <a-entity
        id="rig"
        collider
        movement-controls="fly:false;"
        spawn-in-circle="radius:1"
        networked="template:#avatar-template;attachTemplateToLocal:false"
        player-info
      >
        <a-entity id="player" class="camera" camera position="0 1.6 0" look-controls>
          <a-box obb-collider visible="false" height="0.4" depth="0.4" width="0.4"></a-box>
          <!-- Ring cursor for better interaction -->
          <a-entity
            position="0 0 -1"
            geometry="primitive: ring; radiusInner: 0.018; radiusOuter: 0.025"
            material="shader: flat; opacity: 0.9"
            cursor="fuse: true; fuseTimeout: 1200"
            raycaster="objects: .clickable; far: 20;"
            animation__fuse="property: scale; startEvents: fusing; from: 1 1 1; to: 0.2 0.2 0.2; dur: 1200; easing: linear"
            animation__reset="property: scale; startEvents: mouseleave; to: 1 1 1; dur: 120">
          </a-entity>
        </a-entity>
        <a-entity id="left-hand" networked-hand-controls="hand: left" laser-controls="hand: left"></a-entity>
        <a-entity id="right-hand" networked-hand-controls="hand:right" laser-controls="hand: right"></a-entity>
      </a-entity>
    </a-scene>

    <!-- Physics Control Panel -->
    <div id="physics-panel" style="position: fixed; top: 10px; left: 10px; background: rgba(0,0,0,0.8); color: white; padding: 20px; border-radius: 10px; font-family: Arial; z-index: 1000;">
      <h3 style="margin-top: 0;">Physics Simulation Control</h3>
      
      <div style="margin-bottom: 15px;">
        <label>Force (N): </label>
        <input type="number" id="force-input" value="100" min="0" max="5000" step="10" style="width: 80px;">
      </div>
      
      <div style="margin-bottom: 15px;">
        <label>Distance (m): </label>
        <input type="number" id="distance-input" value="5" min="0" max="50" step="0.5" style="width: 80px;">
      </div>
      
      <div style="margin-bottom: 15px;">
        <button id="apply-force-btn" style="background: #4CAF50; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer;">Apply Force</button>
        <button id="reset-btn" style="background: #f44336; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; margin-left: 10px;">Reset</button>
      </div>
      
      <hr style="border-color: #555;">
      
      <div style="margin-bottom: 10px;">
        <h4 style="margin-bottom: 5px;">Car Data:</h4>
        <div>Mass: <span id="car-mass">1200</span> kg</div>
        <div>Acceleration: <span id="car-acceleration">0</span> m/s²</div>
        <div>Velocity: <span id="car-velocity">0</span> m/s</div>
        <div>Distance Traveled: <span id="car-distance">0</span> m</div>
      </div>
      
      <div style="margin-bottom: 10px;">
        <h4 style="margin-bottom: 5px;">Bicycle Data:</h4>
        <div>Mass: <span id="bicycle-mass">50</span> kg</div>
        <div>Acceleration: <span id="bicycle-acceleration">0</span> m/s²</div>
        <div>Velocity: <span id="bicycle-velocity">0</span> m/s</div>
        <div>Distance Traveled: <span id="bicycle-distance">0</span> m</div>
      </div>
    </div>

    <script>
      // Component to make one entity follow another
      AFRAME.registerComponent('follow', {
        schema: { target: { type: 'selector' } },
        tick: function () {
          if (!this.data.target) return;
          this.el.object3D.position.copy(this.data.target.object3D.position);
          this.el.object3D.quaternion.copy(this.data.target.object3D.quaternion);
        },
      });

      // Player collider: stops the player from penetrating any .collidable object
      AFRAME.registerComponent('collider', {
        schema: { distance: { default: 1.2 } },
        init: function () {
          this.raycaster = new THREE.Raycaster();
          this.lastSafePosition = new THREE.Vector3();
          this.directions = [
            new THREE.Vector3(0, 0, -1), // forward
            new THREE.Vector3(0, 0, 1), // backward
            new THREE.Vector3(-1, 0, 0), // left
            new THREE.Vector3(1, 0, 0), // right
            new THREE.Vector3(-0.7, 0, -0.7), // diagonal front-left
            new THREE.Vector3(0.7, 0, -0.7), // diagonal front-right
            new THREE.Vector3(-0.7, 0, 0.7), // diagonal back-left
            new THREE.Vector3(0.7, 0, 0.7), // diagonal back-right
          ];
          this.el.addEventListener('loaded', () => {
            this.el.object3D.getWorldPosition(this.lastSafePosition);
          });
        },
        tick: function (time, delta) {
          const collidableEls = this.el.sceneEl.querySelectorAll('.collidable');
          if (collidableEls.length === 0) return;

          const collidables = [];
          collidableEls.forEach((el) => {
            if (el.object3D) {
              collidables.push(el.object3D);
            }
          });

          let collision = false;
          for (const dir of this.directions) {
            const worldDir = dir.clone().applyQuaternion(this.el.object3D.quaternion);
            this.raycaster.set(this.el.object3D.position, worldDir);
            this.raycaster.far = this.data.distance;
            const intersects = this.raycaster.intersectObjects(collidables, true);

            if (intersects.length > 0 && intersects[0].distance < this.data.distance) {
              const hitEl = intersects[0].object.el;
              if (hitEl && hitEl.components && hitEl.components.pushable) {
                const pushStrength = 0.02; // Increased push strength
                const pushVector = worldDir.clone().multiplyScalar(pushStrength * delta);
                hitEl.components.pushable.push(pushVector);
                console.log('Pushing object:', hitEl.id, 'with vector:', pushVector);
              }
              this.el.object3D.position.copy(this.lastSafePosition);
              collision = true;
              break;
            }
          }
          if (!collision) {
            this.el.object3D.getWorldPosition(this.lastSafePosition);
          }
        },
      });

      // Pushable component: handles its own gravity and can be pushed
      AFRAME.registerComponent('pushable', {
        init: function () {
          this.raycaster = new THREE.Raycaster();
          this.downVector = new THREE.Vector3(0, -1, 0);
          this.velocity = new THREE.Vector3();
          this.friction = 0.92;
        },
        push: function (vector) {
          // Only allow pushing from front or back, not sides
          if (Math.abs(vector.x) > Math.abs(vector.z)) {
            return;
          }
          this.velocity.add(vector);

          // If this element has a parent group, move the entire group
          const parentGroup = this.el.parentNode;
          if (parentGroup && parentGroup.id === 'car-group') {
            parentGroup.object3D.position.add(vector);
          } else {
            this.el.object3D.position.add(vector);
          }

          // Update all connected objects (like the visual ferrari model)
          const followingElements = this.el.sceneEl.querySelectorAll('[follow]');
          followingElements.forEach((follower) => {
            const followComponent = follower.components.follow;
            if (followComponent && followComponent.data.target === this.el) {
              follower.object3D.position.copy(this.el.object3D.position);
            }
          });
        },
        tick: function () {
          // Apply friction
          this.velocity.multiplyScalar(this.friction);

          // Apply small remaining velocity
          if (this.velocity.length() > 0.001) {
            const parentGroup = this.el.parentNode;
            if (parentGroup && parentGroup.id === 'car-group') {
              parentGroup.object3D.position.add(this.velocity.clone().multiplyScalar(0.1));
            } else {
              this.el.object3D.position.add(this.velocity.clone().multiplyScalar(0.1));
            }
          }

          // Apply gravity/ground constraint
          const groundEls = this.el.sceneEl.querySelectorAll('.ground, .environmentGround');
          if (groundEls.length === 0) return;
          const grounds = [];
          groundEls.forEach((el) => grounds.push(el.object3D));

          this.raycaster.set(this.el.object3D.position, this.downVector);
          const intersects = this.raycaster.intersectObjects(grounds, true);
          if (intersects.length > 0) {
            const height = this.el.getAttribute('height') || this.el.getAttribute('geometry')?.height || 0.1;
            this.el.object3D.position.y = intersects[0].point.y + height / 2;
          }
        },
      });

      // Physics Object Component
      AFRAME.registerComponent('physics-object', {
        schema: {
          mass: { default: 1 }
        },
        init: function () {
          this.velocity = new THREE.Vector3();
          this.acceleration = new THREE.Vector3();
          this.appliedForce = new THREE.Vector3();
          this.isMoving = false;
          this.distanceTraveled = 0;
          this.startPosition = new THREE.Vector3();
          this.targetDistance = 0;
          this.friction = 0.995; // Reduced friction for better movement
          
          // Wait for the element to be loaded before capturing start position
          this.el.addEventListener('loaded', () => {
            setTimeout(() => this.captureStartPosition(), 500);
          });
          
          // If already loaded, capture immediately
          if (this.el.hasLoaded) {
            setTimeout(() => this.captureStartPosition(), 500);
          }
        },
        captureStartPosition: function() {
          // Get position from parent group if it exists
          const parentGroup = this.el.parentNode;
          if (parentGroup && (parentGroup.id === 'car-group' || parentGroup.id === 'sepeda-group')) {
            const pos = parentGroup.getAttribute('position');
            this.startPosition.set(pos.x, pos.y, pos.z);
          } else {
            const pos = this.el.getAttribute('position');
            this.startPosition.set(pos.x, pos.y, pos.z);
          }
          console.log(`Start position captured for ${this.el.id}:`, this.startPosition);
        },
        applyForce: function (force, targetDistance) {
          this.appliedForce.copy(force);
          this.acceleration.copy(force).divideScalar(this.data.mass);
          this.isMoving = true;
          this.distanceTraveled = 0;
          this.targetDistance = targetDistance;
          this.captureStartPosition();
          
          console.log(`Applying force to ${this.el.id}:`, {
            force: force,
            mass: this.data.mass,
            acceleration: this.acceleration,
            targetDistance: targetDistance
          });
        },
        tick: function (time, delta) {
          if (!this.isMoving) return;

          const deltaTime = delta / 1000; // Convert to seconds

          // Apply acceleration to velocity
          this.velocity.add(this.acceleration.clone().multiplyScalar(deltaTime));
          
          // Apply friction
          this.velocity.multiplyScalar(this.friction);

          // Update position - move the parent group if it exists
          const movement = this.velocity.clone().multiplyScalar(deltaTime);
          const parentGroup = this.el.parentNode;
          
          let currentPos;
          if (parentGroup && (parentGroup.id === 'car-group' || parentGroup.id === 'sepeda-group')) {
            currentPos = parentGroup.getAttribute('position');
            const newPos = {
              x: currentPos.x + movement.x,
              y: currentPos.y + movement.y,
              z: currentPos.z + movement.z
            };
            parentGroup.setAttribute('position', newPos);
            console.log(`Moving ${parentGroup.id} from`, currentPos, 'to', newPos, 'movement:', movement);
            this.distanceTraveled = Math.sqrt(
              Math.pow(newPos.x - this.startPosition.x, 2) +
              Math.pow(newPos.y - this.startPosition.y, 2) +
              Math.pow(newPos.z - this.startPosition.z, 2)
            );
          } else {
            currentPos = this.el.getAttribute('position');
            const newPos = {
              x: currentPos.x + movement.x,
              y: currentPos.y + movement.y,
              z: currentPos.z + movement.z
            };
            this.el.setAttribute('position', newPos);
            console.log(`Moving ${this.el.id} from`, currentPos, 'to', newPos, 'movement:', movement);
            this.distanceTraveled = Math.sqrt(
              Math.pow(newPos.x - this.startPosition.x, 2) +
              Math.pow(newPos.y - this.startPosition.y, 2) +
              Math.pow(newPos.z - this.startPosition.z, 2)
            );
          }

          // Stop if target distance reached or velocity is very small
          if (this.distanceTraveled >= this.targetDistance || this.velocity.length() < 0.01) {
            this.isMoving = false;
            this.velocity.set(0, 0, 0);
            // Don't reset acceleration - keep it for display until manual reset
            console.log(`${this.el.id} stopped. Distance traveled: ${this.distanceTraveled}`);
            console.log(`Final acceleration was: ${this.acceleration.length()}`);
          }

          // Update UI and arrow
          this.updateUI();
          this.updateArrow();
        },
        updateUI: function () {
          const objectType = this.el.id.includes('ferrari') ? 'car' : 'bicycle';
          
          // Force DOM update by using requestAnimationFrame
          requestAnimationFrame(() => {
            const massEl = document.getElementById(`${objectType}-mass`);
            const accelEl = document.getElementById(`${objectType}-acceleration`);
            const velocityEl = document.getElementById(`${objectType}-velocity`);
            const distanceEl = document.getElementById(`${objectType}-distance`);
            
            if (massEl) massEl.textContent = this.data.mass;
            if (accelEl) accelEl.textContent = this.acceleration.length().toFixed(2);
            if (velocityEl) velocityEl.textContent = this.velocity.length().toFixed(2);
            if (distanceEl) distanceEl.textContent = this.distanceTraveled.toFixed(2);
            
            console.log(`UI Updated for ${objectType}:`, {
              mass: this.data.mass,
              acceleration: this.acceleration.length().toFixed(2),
              velocity: this.velocity.length().toFixed(2),
              distance: this.distanceTraveled.toFixed(2)
            });
          });
        },
        updateArrow: function () {
          const objectType = this.el.id.includes('ferrari') ? 'car' : 'sepeda';
          const arrow = document.getElementById(`${objectType}-arrow`);
          
          console.log(`updateArrow called for ${this.el.id}, objectType: ${objectType}, arrow found: ${!!arrow}`);
          console.log(`Current acceleration magnitude: ${this.acceleration.length()}`);
          console.log(`Current velocity magnitude: ${this.velocity.length()}`);
          console.log(`Is moving: ${this.isMoving}`);
          
          if (!arrow) {
            console.error(`Arrow not found for ${objectType}`);
            return;
          }
          
          // Show arrow if there's any acceleration data (even when stopped)
          if (this.acceleration.length() > 0) {
            arrow.setAttribute('visible', true);
            
            // Scale arrow based on acceleration magnitude (more responsive scaling)
            const accelerationMagnitude = this.acceleration.length();
            const minScale = 0.3;
            const maxScale = 5.0;
            const scaleFactor = 2.0; // Increased sensitivity to acceleration
            
            // More aggressive scaling based on acceleration
            let scale = minScale + (accelerationMagnitude * scaleFactor);
            scale = Math.max(minScale, Math.min(maxScale, scale));
            
            console.log(`${objectType} - Acceleration: ${accelerationMagnitude.toFixed(3)}, Scale: ${scale.toFixed(2)}`);
            
            arrow.setAttribute('scale', `${scale} ${scale} ${scale}`);
            
            // Point arrow in direction of movement (use last known direction if stopped)
            if (this.isMoving && this.velocity.length() > 0.01) {
              const direction = this.velocity.clone().normalize();
              let angle = Math.atan2(direction.x, direction.z) * 180 / Math.PI;
              angle = angle + 90; // Rotate arrow 90 degrees to the right
              arrow.setAttribute('rotation', `0 ${angle} 0`);
            }
            
            console.log(`Arrow visible for ${objectType}, scale: ${scale.toFixed(2)}, acceleration: ${accelerationMagnitude.toFixed(2)}`);
          } else {
            arrow.setAttribute('visible', false);
          }
        }
      });

      // Physics Simulation Manager
      class PhysicsSimulation {
        constructor() {
          this.setupEventListeners();
        }

        setupEventListeners() {
          document.getElementById('apply-force-btn').addEventListener('click', () => {
            this.applyForce();
          });

          document.getElementById('reset-btn').addEventListener('click', () => {
            this.reset();
          });
        }

        applyForce() {
          const forceValue = parseFloat(document.getElementById('force-input').value) || 0;
          const distance = parseFloat(document.getElementById('distance-input').value) || 0;

          console.log(`Applying force: ${forceValue}N, Distance: ${distance}m`);

          // Apply force to car (backward direction) - multiply by 50 for more visible effect
          const carBody = document.getElementById('ferrari-body');
          if (carBody && carBody.components && carBody.components['physics-object']) {
            const carForce = new THREE.Vector3(0, 0, forceValue * 50); // Backward direction with multiplier
            carBody.components['physics-object'].applyForce(carForce, distance);
            console.log('Force applied to car');
          } else {
            console.error('Car physics object not found or not initialized');
          }

          // Apply force to bicycle (backward direction) - multiply by 50 for more visible effect
          const bicycleBody = document.getElementById('sepeda-body');
          if (bicycleBody && bicycleBody.components && bicycleBody.components['physics-object']) {
            const bicycleForce = new THREE.Vector3(0, 0, forceValue * 50); // Backward direction with multiplier
            bicycleBody.components['physics-object'].applyForce(bicycleForce, distance);
            console.log('Force applied to bicycle');
          } else {
            console.error('Bicycle physics object not found or not initialized');
          }
        }

        reset() {
          console.log('Resetting simulation...');
          
          // Reset car position
          const carGroup = document.getElementById('car-group');
          if (carGroup) {
            carGroup.setAttribute('position', '0 0 2');
            console.log('Car position reset to 0 0 2');
          }
          
          // Reset bicycle position
          const bicycleGroup = document.getElementById('sepeda-group');
          if (bicycleGroup) {
            bicycleGroup.setAttribute('position', '3 0.6 3');
            console.log('Bicycle position reset to 3 0.6 3');
          }

          // Reset physics components
          setTimeout(() => {
            const carBody = document.getElementById('ferrari-body');
            if (carBody && carBody.components && carBody.components['physics-object']) {
              const physics = carBody.components['physics-object'];
              physics.velocity.set(0, 0, 0);
              physics.acceleration.set(0, 0, 0);
              physics.isMoving = false;
              physics.distanceTraveled = 0;
              physics.captureStartPosition();
            }

            const bicycleBody = document.getElementById('sepeda-body');
            if (bicycleBody && bicycleBody.components && bicycleBody.components['physics-object']) {
              const physics = bicycleBody.components['physics-object'];
              physics.velocity.set(0, 0, 0);
              physics.acceleration.set(0, 0, 0);
              physics.isMoving = false;
              physics.distanceTraveled = 0;
              physics.captureStartPosition();
            }

            // Hide arrows
            const carArrow = document.getElementById('car-arrow');
            const sepedaArrow = document.getElementById('sepeda-arrow');
            if (carArrow) carArrow.setAttribute('visible', false);
            if (sepedaArrow) sepedaArrow.setAttribute('visible', false);

            // Reset UI displays with force update
            requestAnimationFrame(() => {
              const elements = [
                'car-acceleration', 'car-velocity', 'car-distance',
                'bicycle-acceleration', 'bicycle-velocity', 'bicycle-distance'
              ];
              
              elements.forEach(id => {
                const element = document.getElementById(id);
                if (element) {
                  element.textContent = '0';
                  console.log(`Reset ${id} to 0`);
                }
              });
            });
          }, 100);
        }
      }

      // Initialize physics simulation when scene and DOM are loaded
      document.addEventListener('DOMContentLoaded', () => {
        // Wait a bit more for A-Frame to fully initialize
        setTimeout(() => {
          console.log('Initializing Physics Simulation...');
          const simulation = new PhysicsSimulation();
          
          // Test if elements are available
          const carBody = document.getElementById('ferrari-body');
          const bicycleBody = document.getElementById('sepeda-body');
          console.log('Car body element:', carBody);
          console.log('Bicycle body element:', bicycleBody);
        }, 1000);
      });
    </script>
  </body>
</html>